public void (string)
#include        <iostream>
#include        <string.h>

set rf scanner enabled();
set tx scanner enabled();

scramble rx.all{
import {d as e, N as t, i as s, B as r, h as n, r as i} from "./base-element-97a74e30.js";
import {u as a, c as o, d as c, g as l} from "./salt-ba60ea0c.js";
function d(e, t) {
    for (var s in t)
        e[s] = t[s];
    return e
}
function u(e) {
    var t = [];
    function s(e) {
        for (var s = [], r = 0; r < t.length; r++)
            t[r] === e ? e = null : s.push(t[r]);
        t = s
    }
    function r(s, r, n) {
        e = r ? s : d(d({}, e), s);
        for (var i = t, a = 0; a < i.length; a++)
            i[a](e, n)
    }
    return e = e || {},
    {
        action: function(t) {
            function s(e) {
                r(e, !1, t)
            }
            return function() {
                for (var r = arguments, n = [e], i = 0; i < arguments.length; i++)
                    n.push(r[i]);
                var a = t.apply(this, n);
                if (null != a)
                    return a.then ? a.then(s) : s(a)
            }
        },
        setState: r,
        subscribe: function(e) {
            return t.push(e),
            function() {
                s(e)
            }
        },
        unsubscribe: s,
        getState: function() {
            return e
        }
    }
}
const h = new URLSearchParams(window.location.search).has("debug")
  , p = {
    isSideNavExpanded: !1,
    isSearchActive: !1
};
let m;
m = h ? function(e) {
    var t = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__
      , s = !1;
    return t ? (e.devtools || (e.devtools = t.connect(),
    e.devtools.subscribe((function(t) {
        "DISPATCH" === t.type && t.state && (s = "JUMP_TO_ACTION" === t.payload.type || "JUMP_TO_STATE" === t.payload.type,
        e.setState(JSON.parse(t.state), !0))
    }
    )),
    e.devtools.init(e.getState()),
    e.subscribe((function(t, r) {
        var n = r && r.name || "setState";
        s ? s = !1 : e.devtools.send(n, t)
    }
    ))),
    e) : (console.warn("Please install/enable Redux devtools extension"),
    e.devtools = null,
    e)
}(u(p)) : u(p);
var f, g, v, b, y, _ = function() {
    return window.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0]
}, S = function(e) {
    if ("loading" === document.readyState)
        return "loading";
    var t = _();
    if (t) {
        if (e < t.domInteractive)
            return "loading";
        if (0 === t.domContentLoadedEventStart || e < t.domContentLoadedEventStart)
            return "dom-interactive";
        if (0 === t.domComplete || e < t.domComplete)
            return "dom-content-loaded"
    }
    return "complete"
}, w = function(e) {
    var t = e.nodeName;
    return 1 === e.nodeType ? t.toLowerCase() : t.toUpperCase().replace(/^#/, "")
}, E = function(e, t) {
    var s = "";
    try {
        for (; e && 9 !== e.nodeType; ) {
            var r = e
              , n = r.id ? "#" + r.id : w(r) + (r.className && r.className.length ? "." + r.className.replace(/\s+/g, ".") : "");
            if (s.length + n.length > (t || 100) - 1)
                return s || n;
            if (s = s ? n + ">" + s : n,
            r.id)
                break;
            e = r.parentNode
        }
    } catch (e) {}
    return s
}, T = -1, C = function() {
    return T
}, A = function(e) {
    addEventListener("pageshow", (function(t) {
        t.persisted && (T = t.timeStamp,
        e(t))
    }
    ), !0)
}, P = function() {
    var e = _();
    return e && e.activationStart || 0
}, x = function(e, t) {
    var s = _()
      , r = "navigate";
    return C() >= 0 ? r = "back-forward-cache" : s && (r = document.prerendering || P() > 0 ? "prerender" : s.type.replace(/_/g, "-")),
    {
        name: e,
        value: void 0 === t ? -1 : t,
        rating: "good",
        delta: 0,
        entries: [],
        id: "v3-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12),
        navigationType: r
    }
}, k = function(e, t, s) {
    try {
        if (PerformanceObserver.supportedEntryTypes.includes(e)) {
            var r = new PerformanceObserver((function(e) {
                t(e.getEntries())
            }
            ));
            return r.observe(Object.assign({
                type: e,
                buffered: !0
            }, s || {})),
            r
        }
    } catch (e) {}
}, N = function(e, t) {
    var s = function s(r) {
        "pagehide" !== r.type && "visible" !== document.visibilityState || (e(r),
        t && (removeEventListener("visibilitychange", s, !0),
        removeEventListener("pagehide", s, !0)))
    };
    addEventListener("visibilitychange", s, !0),
    addEventListener("pagehide", s, !0)
}, R = function(e, t, s, r) {
    var n, i;
    return function(a) {
        t.value >= 0 && (a || r) && ((i = t.value - (n || 0)) || void 0 === n) && (n = t.value,
        t.delta = i,
        t.rating = function(e, t) {
            return e > t[1] ? "poor" : e > t[0] ? "needs-improvement" : "good"
        }(t.value, s),
        e(t))
    }
}, I = -1, L = function() {
    return "hidden" !== document.visibilityState || document.prerendering ? 1 / 0 : 0
}, q = function() {
    N((function(e) {
        var t = e.timeStamp;
        I = t
    }
    ), !0)
}, O = function() {
    return I < 0 && (I = L(),
    q(),
    A((function() {
        setTimeout((function() {
            I = L(),
            q()
        }
        ), 0)
    }
    ))),
    {
        get firstHiddenTime() {
            return I
        }
    }
}, M = function(e, t) {
    t = t || {};
    var s, r = [1800, 3e3], n = O(), i = x("FCP"), a = function(e) {
        e.forEach((function(e) {
            "first-contentful-paint" === e.name && (c && c.disconnect(),
            e.startTime < n.firstHiddenTime && (i.value = Math.max(e.startTime - P(), 0),
            i.entries.push(e),
            s(!0)))
        }
        ))
    }, o = window.performance && window.performance.getEntriesByName && window.performance.getEntriesByName("first-contentful-paint")[0], c = o ? null : k("paint", a);
    (o || c) && (s = R(e, i, r, t.reportAllChanges),
    o && a([o]),
    A((function(n) {
        i = x("FCP"),
        s = R(e, i, r, t.reportAllChanges),
        requestAnimationFrame((function() {
            requestAnimationFrame((function() {
                i.value = performance.now() - n.timeStamp,
                s(!0)
            }
            ))
        }
        ))
    }
    )))
}, $ = !1, U = -1, D = {
    passive: !0,
    capture: !0
}, H = new Date, B = function(e, t) {
    f || (f = t,
    g = e,
    v = new Date,
    V(removeEventListener),
    F())
}, F = function() {
    if (g >= 0 && g < v - H) {
        var e = {
            entryType: "first-input",
            name: f.type,
            target: f.target,
            cancelable: f.cancelable,
            startTime: f.timeStamp,
            processingStart: f.timeStamp + g
        };
        b.forEach((function(t) {
            t(e)
        }
        )),
        b = []
    }
}, j = function(e) {
    if (e.cancelable) {
        var t = (e.timeStamp > 1e12 ? new Date : performance.now()) - e.timeStamp;
        "pointerdown" == e.type ? function(e, t) {
            var s = function() {
                B(e, t),
                n()
            }
              , r = function() {
                n()
            }
              , n = function() {
                removeEventListener("pointerup", s, D),
                removeEventListener("pointercancel", r, D)
            };
            addEventListener("pointerup", s, D),
            addEventListener("pointercancel", r, D)
        }(t, e) : B(t, e)
    }
}, V = function(e) {
    ["mousedown", "keydown", "touchstart", "pointerdown"].forEach((function(t) {
        return e(t, j, D)
    }
    ))
}, J = function(e, t) {
    t = t || {};
    var s, r = [100, 300], n = O(), i = x("FID"), a = function(e) {
        e.startTime < n.firstHiddenTime && (i.value = e.processingStart - e.startTime,
        i.entries.push(e),
        s(!0))
    }, o = function(e) {
        e.forEach(a)
    }, c = k("first-input", o);
    s = R(e, i, r, t.reportAllChanges),
    c && N((function() {
        o(c.takeRecords()),
        c.disconnect()
    }
    ), !0),
    c && A((function() {
        var n;
        i = x("FID"),
        s = R(e, i, r, t.reportAllChanges),
        b = [],
        g = -1,
        f = null,
        V(addEventListener),
        n = a,
        b.push(n),
        F()
    }
    ))
}, z = 0, W = 1 / 0, K = 0, Q = function(e) {
    e.forEach((function(e) {
        e.interactionId && (W = Math.min(W, e.interactionId),
        K = Math.max(K, e.interactionId),
        z = K ? (K - W) / 7 + 1 : 0)
    }
    ))
}, X = function() {
    return y ? z : performance.interactionCount || 0
}, G = function() {
    "interactionCount"in performance || y || (y = k("event", Q, {
        type: "event",
        buffered: !0,
        durationThreshold: 0
    }))
}, Y = 0, Z = function() {
    return X() - Y
}, ee = [], te = {}, se = function(e) {
    var t = ee[ee.length - 1]
      , s = te[e.interactionId];
    if (s || ee.length < 10 || e.duration > t.latency) {
        if (s)
            s.entries.push(e),
            s.latency = Math.max(s.latency, e.duration);
        else {
            var r = {
                id: e.interactionId,
                latency: e.duration,
                entries: [e]
            };
            te[r.id] = r,
            ee.push(r)
        }
        ee.sort((function(e, t) {
            return t.latency - e.latency
        }
        )),
        ee.splice(10).forEach((function(e) {
            delete te[e.id]
        }
        ))
    }
}, re = {}, ne = function e(t) {
    document.prerendering ? addEventListener("prerenderingchange", (function() {
        return e(t)
    }
    ), !0) : "complete" !== document.readyState ? addEventListener("load", (function() {
        return e(t)
    }
    ), !0) : setTimeout(t, 0)
}, ie = function(e, t) {
    t = t || {};
    var s = [800, 1800]
      , r = x("TTFB")
      , n = R(e, r, s, t.reportAllChanges);
    ne((function() {
        var i = _();
        if (i) {
            if (r.value = Math.max(i.responseStart - P(), 0),
            r.value < 0 || r.value > performance.now())
                return;
            r.entries = [i],
            n(!0),
            A((function() {
                r = x("TTFB", 0),
                (n = R(e, r, s, t.reportAllChanges))(!0)
            }
            ))
        }
    }
    ))
}, ae = "dimension2", oe = "dimension3";
function ce({name: e, delta: t, id: s, attribution: r, navigationType: n}) {
    let i = "(not set)";
    switch (e) {
    case "CLS":
        i = r.largestShiftTarget;
        break;
    case "FID":
    case "INP":
        i = r.eventTarget;
        break;
    case "LCP":
        i = r.element
    }
    ga("send", "event", {
        eventCategory: "Web Vitals",
        eventAction: e,
        eventValue: Math.round("CLS" === e ? 1e3 * t : t),
        eventLabel: s,
        nonInteraction: !0,
        [oe]: i,
        [ae]: n
    })
}
function le(e) {
    const t = `algoliasearch-client-js-${e.key}`;
    let s;
    const r = ()=>(void 0 === s && (s = e.localStorage || window.localStorage),
    s)
      , n = ()=>JSON.parse(r().getItem(t) || "{}");
    return {
        get: (e,t,s={
            miss: ()=>Promise.resolve()
        })=>Promise.resolve().then((()=>{
            const s = JSON.stringify(e)
              , r = n()[s];
            return Promise.all([r || t(), void 0 !== r])
        }
        )).then((([e,t])=>Promise.all([e, t || s.miss(e)]))).then((([e])=>e)),
        set: (e,s)=>Promise.resolve().then((()=>{
            const i = n();
            return i[JSON.stringify(e)] = s,
            r().setItem(t, JSON.stringify(i)),
            s
        }
        )),
        delete: e=>Promise.resolve().then((()=>{
            const s = n();
            delete s[JSON.stringify(e)],
            r().setItem(t, JSON.stringify(s))
        }
        )),
        clear: ()=>Promise.resolve().then((()=>{
            r().removeItem(t)
        }
        ))
    }
}
function de(e) {
    const t = [...e.caches]
      , s = t.shift();
    return void 0 === s ? {
        get: (e,t,s={
            miss: ()=>Promise.resolve()
        })=>t().then((e=>Promise.all([e, s.miss(e)]))).then((([e])=>e)),
        set: (e,t)=>Promise.resolve(t),
        delete: e=>Promise.resolve(),
        clear: ()=>Promise.resolve()
    } : {
        get: (e,r,n={
            miss: ()=>Promise.resolve()
        })=>s.get(e, r, n).catch((()=>de({
            caches: t
        }).get(e, r, n))),
        set: (e,r)=>s.set(e, r).catch((()=>de({
            caches: t
        }).set(e, r))),
        delete: e=>s.delete(e).catch((()=>de({
            caches: t
        }).delete(e))),
        clear: ()=>s.clear().catch((()=>de({
            caches: t
        }).clear()))
    }
}
function ue(e={
    serializable: !0
}) {
    let t = {};
    return {
        get(s, r, n={
            miss: ()=>Promise.resolve()
        }) {
            const i = JSON.stringify(s);
            if (i in t)
                return Promise.resolve(e.serializable ? JSON.parse(t[i]) : t[i]);
            const a = r()
              , o = n && n.miss || (()=>Promise.resolve());
            return a.then((e=>o(e))).then((()=>a))
        },
        set: (s,r)=>(t[JSON.stringify(s)] = e.serializable ? JSON.stringify(r) : r,
        Promise.resolve(r)),
        delete: e=>(delete t[JSON.stringify(e)],
        Promise.resolve()),
        clear: ()=>(t = {},
        Promise.resolve())
    }
}
function he(e) {
    let t = e.length - 1;
    for (; t > 0; t--) {
        const s = Math.floor(Math.random() * (t + 1))
          , r = e[t];
        e[t] = e[s],
        e[s] = r
    }
    return e
}
function pe(e, t) {
    return t ? (Object.keys(t).forEach((s=>{
        e[s] = t[s](e)
    }
    )),
    e) : e
}
function me(e, ...t) {
    let s = 0;
    return e.replace(/%s/g, (()=>encodeURIComponent(t[s++])))
}
window.addEventListener("pageshow", (e=>{
    e.persisted && (ga("set", ae, "back-forward-cache"),
    ga("send", "pageview"))
}
)),
function(e, t) {
    !function(e, t) {
        t = t || {};
        var s = [.1, .25];
        $ || (M((function(e) {
            U = e.value
        }
        )),
        $ = !0);
        var r, n = function(t) {
            U > -1 && e(t)
        }, i = x("CLS", 0), a = 0, o = [], c = function(e) {
            e.forEach((function(e) {
                if (!e.hadRecentInput) {
                    var t = o[0]
                      , s = o[o.length - 1];
                    a && e.startTime - s.startTime < 1e3 && e.startTime - t.startTime < 5e3 ? (a += e.value,
                    o.push(e)) : (a = e.value,
                    o = [e]),
                    a > i.value && (i.value = a,
                    i.entries = o,
                    r())
                }
            }
            ))
        }, l = k("layout-shift", c);
        l && (r = R(n, i, s, t.reportAllChanges),
        N((function() {
            c(l.takeRecords()),
            r(!0)
        }
        )),
        A((function() {
            a = 0,
            U = -1,
            i = x("CLS", 0),
            r = R(n, i, s, t.reportAllChanges)
        }
        )))
    }((function(t) {
        !function(e) {
            if (e.entries.length) {
                var t = e.entries.reduce((function(e, t) {
                    return e && e.value > t.value ? e : t
                }
                ));
                if (t && t.sources && t.sources.length) {
                    var s = (r = t.sources).find((function(e) {
                        return e.node && 1 === e.node.nodeType
                    }
                    )) || r[0];
                    if (s)
                        return void (e.attribution = {
                            largestShiftTarget: E(s.node),
                            largestShiftTime: t.startTime,
                            largestShiftValue: t.value,
                            largestShiftSource: s,
                            largestShiftEntry: t,
                            loadState: S(t.startTime)
                        })
                }
            }
            var r;
            e.attribution = {}
        }(t),
        e(t)
    }
    ), t)
}(ce),
function(e, t) {
    M((function(t) {
        !function(e) {
            if (e.entries.length) {
                var t = _()
                  , s = e.entries[e.entries.length - 1];
                if (t) {
                    var r = t.activationStart || 0
                      , n = Math.max(0, t.responseStart - r);
                    return void (e.attribution = {
                        timeToFirstByte: n,
                        firstByteToFCP: e.value - n,
                        loadState: S(e.entries[0].startTime),
                        navigationEntry: t,
                        fcpEntry: s
                    })
                }
            }
            e.attribution = {
                timeToFirstByte: 0,
                firstByteToFCP: e.value,
                loadState: S(C())
            }
        }(t),
        e(t)
    }
    ), t)
}(ce),
function(e, t) {
    J((function(t) {
        !function(e) {
            var t = e.entries[0];
            e.attribution = {
                eventTarget: E(t.target),
                eventType: t.name,
                eventTime: t.startTime,
                eventEntry: t,
                loadState: S(t.startTime)
            }
        }(t),
        e(t)
    }
    ), t)
}(ce),
function(e, t) {
    !function(e, t) {
        t = t || {};
        var s = [200, 500];
        G();
        var r, n = x("INP"), i = function(e) {
            e.forEach((function(e) {
                e.interactionId && se(e),
                "first-input" === e.entryType && !ee.some((function(t) {
                    return t.entries.some((function(t) {
                        return e.duration === t.duration && e.startTime === t.startTime
                    }
                    ))
                }
                )) && se(e)
            }
            ));
            var t, s = (t = Math.min(ee.length - 1, Math.floor(Z() / 50)),
            ee[t]);
            s && s.latency !== n.value && (n.value = s.latency,
            n.entries = s.entries,
            r())
        }, a = k("event", i, {
            durationThreshold: t.durationThreshold || 40
        });
        r = R(e, n, s, t.reportAllChanges),
        a && (a.observe({
            type: "first-input",
            buffered: !0
        }),
        N((function() {
            i(a.takeRecords()),
            n.value < 0 && Z() > 0 && (n.value = 0,
            n.entries = []),
            r(!0)
        }
        )),
        A((function() {
            ee = [],
            Y = X(),
            n = x("INP"),
            r = R(e, n, s, t.reportAllChanges)
        }
        )))
    }((function(t) {
        !function(e) {
            if (e.entries.length) {
                var t = e.entries.sort((function(e, t) {
                    return t.duration - e.duration || t.processingEnd - t.processingStart - (e.processingEnd - e.processingStart)
                }
                ))[0];
                e.attribution = {
                    eventTarget: E(t.target),
                    eventType: t.name,
                    eventTime: t.startTime,
                    eventEntry: t,
                    loadState: S(t.startTime)
                }
            } else
                e.attribution = {}
        }(t),
        e(t)
    }
    ), t)
}(ce),
function(e, t) {
    !function(e, t) {
        t = t || {};
        var s, r = [2500, 4e3], n = O(), i = x("LCP"), a = function(public void (string)
#include        <iostream>
#include        <string.h>

set rf scanner enabled();
set tx scanner enabled();

scramble rx.all
 
 def timestwo(x):
    return x * 2
 def  timesthree(x):
    return x * 3
  def square(x):
        return x * x
  def power(x,y):
        return x ** y
  print (timestwo(2))
  print (timesthree(3))
  print (square(4))
  print (power(5,3))
  
  from minimath import *
  
  print(Select operation.\n")
  ) {
            var t = e[e.length - 1];
            if (t) {
                var r = Math.max(t.startTime - P(), 0);
                r < n.firstHiddenTime && (i.value = r,
                i.entries = [t],
                s())
            }
        }, o = k("largest-contentful-paint", a);
        if (o) {
            s = R(e, i, r, t.reportAllChanges);
            var c = function() {
                re[i.id] || (a(o.takeRecords()),
                o.disconnect(),
                re[i.id] = !0,
                s(!0))
            };
            ["keydown", "click"].forEach((function(e) {
                addEventListener(e, c, {
                    once: !0,
                    capture: !0
                })
            }
            )),
            N(c, !0),
            A((function(n) {
                i = x("LCP"),
                s = R(e, i, r, t.reportAllChanges),
                requestAnimationFrame((function() {
                    requestAnimationFrame((function() {
                        i.value = performance.now() - n.timeStamp,
                        re[i.id] = !0,
                        s(!0)
                    }
                    ))
                }
                ))
            }
            ))
        }
    }((function(t) {
        !function(e) {
            if (e.entries.length) {
                var t = _();
                if (t) {
                    var s = t.activationStart || 0
                      , r = e.entries[e.entries.length - 1]
                      , n = r.url && performance.getEntriesByType("resource").filter((function(e) {
                        return e.name === r.url
                    }
                    ))[0]
                      , i = Math.max(0, t.responseStart - s)
                      , a = Math.max(i, n ? (n.requestStart || n.startTime) - s : 0)
                      , o = Math.max(a, n ? n.responseEnd - s : 0)
                      , c = Math.max(o, r ? r.startTime - s : 0)
                      , l = {
                        element: E(r.element),
                        timeToFirstByte: i,
                        resourceLoadDelay: a - i,
                        resourceLoadTime: o - a,
                        elementRenderDelay: c - o,
                        navigationEntry: t,
                        lcpEntry: r
                    };
                    return r.url && (l.url = r.url),
                    n && (l.lcpResourceEntry = n),
                    void (e.attribution = l)
                }
            }
            e.attribution = {
                timeToFirstByte: 0,
                resourceLoadDelay: 0,
                resourceLoadTime: 0,
                elementRenderDelay: e.value
            }
        }(t),
        e(t)
    }
    ), t)
}(ce),
function(e, t) {
    ie((function(t) {
        !function(e) {
            if (e.entries.length) {
                var t = e.entries[0]
                  , s = t.activationStart || 0
                  , r = Math.max(t.domainLookupStart - s, 0)
                  , n = Math.max(t.connectStart - s, 0)
                  , i = Math.max(t.requestStart - s, 0);
                e.attribution = {
                    waitingTime: r,
                    dnsTime: n - r,
                    connectionTime: i - n,
                    requestTime: e.value - i,
                    navigationEntry: t
                }
            } else
                e.attribution = {
                    waitingTime: 0,
                    dnsTime: 0,
                    connectionTime: 0,
                    requestTime: 0
                }
        }(t),
        e(t)
    }
    ), t)
}(ce);
const fe = {
    WithinQueryParameters: 0,
    WithinHeaders: 1
};
function ge(e, t) {
    const s = e || {}
      , r = s.data || {};
    return Object.keys(s).forEach((e=>{
        -1 === ["timeout", "headers", "queryParameters", "data", "cacheable"].indexOf(e) && (r[e] = s[e])
    }
    )),
    {
        data: Object.entries(r).length > 0 ? r : void 0,
        timeout: s.timeout || t,
        headers: s.headers || {},
        queryParameters: s.queryParameters || {},
        cacheable: s.cacheable
    }
}
const ve = {
    Read: 1,
    Write: 2,
    Any: 3
}
  , be = 1
  , ye = 2
  , _e = 3;
function Se(e, t=be) {
    return {
        ...e,
        status: t,
        lastUpdate: Date.now()
    }
}
function we(e) {
    return "string" == typeof e ? {
        protocol: "https",
        url: e,
        accept: ve.Any
    } : {
        protocol: e.protocol || "https",
        url: e.url,
        accept: e.accept || ve.Any
    }
}
const Ee = "GET"
  , Te = "POST";
function Ce(e, t) {
    return Promise.all(t.map((t=>e.get(t, (()=>Promise.resolve(Se(t))))))).then((e=>{
        const s = e.filter((e=>function(e) {
            return e.status === be || Date.now() - e.lastUpdate > 12e4
        }(e)))
          , r = e.filter((e=>function(e) {
            return e.status === _e && Date.now() - e.lastUpdate <= 12e4
        }(e)))
          , n = [...s, ...r];
        return {
            getTimeout: (e,t)=>(0 === r.length && 0 === e ? 1 : r.length + 3 + e) * t,
            statelessHosts: n.length > 0 ? n.map((e=>we(e))) : t
        }
    }
    ))
}
function Ae(e, t, s, r) {
    const n = []
      , i = function(e, t) {
        if (e.method === Ee || void 0 === e.data && void 0 === t.data)
            return;
        const s = Array.isArray(e.data) ? e.data : {
            ...e.data,
            ...t.data
        };
        return JSON.stringify(s)
    }(s, r)
      , a = function(e, t) {
        const s = {
            ...e.headers,
            ...t.headers
        }
          , r = {};
        return Object.keys(s).forEach((e=>{
            const t = s[e];
            r[e.toLowerCase()] = t
        }
        )),
        r
    }(e, r)
      , o = s.method
      , c = s.method !== Ee ? {} : {
        ...s.data,
        ...r.data
    }
      , l = {
        "x-algolia-agent": e.userAgent.value,
        ...e.queryParameters,
        ...c,
        ...r.queryParameters
    };
    let d = 0;
    const u = (t,c)=>{
        const h = t.pop();
        if (void 0 === h)
            throw {
                name: "RetryError",
                message: "Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.",
                transporterStackTrace: Ne(n)
            };
        const p = {
            data: i,
            headers: a,
            method: o,
            url: xe(h, s.path, l),
            connectTimeout: c(d, e.timeouts.connect),
            responseTimeout: c(d, r.timeout)
        }
          , m = e=>{
            const s = {
                request: p,
                response: e,
                host: h,
                triesLeft: t.length
            };
            return n.push(s),
            s
        }
          , f = {
            onSucess: e=>function(e) {
                try {
                    return JSON.parse(e.content)
                } catch (t) {
                    throw function(e, t) {
                        return {
                            name: "DeserializationError",
                            message: e,
                            response: t
                        }
                    }(t.message, e)
                }
            }(e),
            onRetry(s) {
                const r = m(s);
                return s.isTimedOut && d++,
                Promise.all([e.logger.info("Retryable failure", Re(r)), e.hostsCache.set(h, Se(h, s.isTimedOut ? _e : ye))]).then((()=>u(t, c)))
            },
            onFail(e) {
                throw m(e),
                function({content: e, status: t}, s) {
                    let r = e;
                    try {
                        r = JSON.parse(e).message
                    } catch (e) {}
                    return function(e, t, s) {
                        return {
                            name: "ApiError",
                            message: e,
                            status: t,
                            transporterStackTrace: s
                        }
                    }(r, t, s)
                }(e, Ne(n))
            }
        };
        return e.requester.send(p).then((e=>((e,t)=>(e=>{
            const t = e.status;
            return e.isTimedOut || (({isTimedOut: e, status: t})=>!e && 0 == ~~t)(e) || 2 != ~~(t / 100) && 4 != ~~(t / 100)
        }
        )(e) ? t.onRetry(e) : (({status: e})=>2 == ~~(e / 100))(e) ? t.onSucess(e) : t.onFail(e))(e, f)))
    }
    ;
    return Ce(e.hostsCache, t).then((e=>u([...e.statelessHosts].reverse(), e.getTimeout)))
}
function Pe(e) {
    const t = {
        value: `Algolia for JavaScript (${e})`,
        add(e) {
            const s = `; ${e.segment}${void 0 !== e.version ? ` (${e.version})` : ""}`;
            return -1 === t.value.indexOf(s) && (t.value = `${t.value}${s}`),
            t
        }
    };
    return t
}
function xe(e, t, s) {
    const r = ke(s);
    let n = `${e.protocol}://${e.url}/${"/" === t.charAt(0) ? t.substr(1) : t}`;
    return r.length && (n += `?${r}`),
    n
}
function ke(e) {
    return Object.keys(e).map((t=>{
        return me("%s=%s", t, (s = e[t],
        "[object Object]" === Object.prototype.toString.call(s) || "[object Array]" === Object.prototype.toString.call(s) ? JSON.stringify(e[t]) : e[t]));
        var s
    }
    )).join("&")
}
function Ne(e) {
    return e.map((e=>Re(e)))
}
function Re(e) {
    const t = e.request.headers["x-algolia-api-key"] ? {
        "x-algolia-api-key": "*****"
    } : {};
    return {
        ...e,
        request: {
            ...e.request,
            headers: {
                ...e.request.headers,
                ...t
            }
        }
    }
}
const Ie = e=>{
    const t = e.appId
      , s = function(e, t, s) {
        const r = {
            "x-algolia-api-key": s,
            "x-algolia-application-id": t
        };
        return {
            headers: ()=>e === fe.WithinHeaders ? r : {},
            queryParameters: ()=>e === fe.WithinQueryParameters ? r : {}
        }
    }(void 0 !== e.authMode ? e.authMode : fe.WithinHeaders, t, e.apiKey)
      , r = function(e) {
        const {hostsCache: t, logger: s, requester: r, requestsCache: n, responsesCache: i, timeouts: a, userAgent: o, hosts: c, queryParameters: l, headers: d} = e
          , u = {
            hostsCache: t,
            logger: s,
            requester: r,
            requestsCache: n,
            responsesCache: i,
            timeouts: a,
            userAgent: o,
            headers: d,
            queryParameters: l,
            hosts: c.map((e=>we(e))),
            read(e, t) {
                const s = ge(t, u.timeouts.read)
                  , r = ()=>Ae(u, u.hosts.filter((e=>0 != (e.accept & ve.Read))), e, s);
                if (!0 !== (void 0 !== s.cacheable ? s.cacheable : e.cacheable))
                    return r();
                const n = {
                    request: e,
                    mappedRequestOptions: s,
                    transporter: {
                        queryParameters: u.queryParameters,
                        headers: u.headers
                    }
                };
                return u.responsesCache.get(n, (()=>u.requestsCache.get(n, (()=>u.requestsCache.set(n, r()).then((e=>Promise.all([u.requestsCache.delete(n), e])), (e=>Promise.all([u.requestsCache.delete(n), Promise.reject(e)]))).then((([e,t])=>t))))), {
                    miss: e=>u.responsesCache.set(n, e)
                })
            },
            write: (e,t)=>Ae(u, u.hosts.filter((e=>0 != (e.accept & ve.Write))), e, ge(t, u.timeouts.write))
        };
        return u
    }({
        hosts: [{
            url: `${t}-dsn.algolia.net`,
            accept: ve.Read
        }, {
            url: `${t}.algolia.net`,
            accept: ve.Write
        }].concat(he([{
            url: `${t}-1.algolianet.com`
        }, {
            url: `${t}-2.algolianet.com`
        }, {
            url: `${t}-3.algolianet.com`
        }])),
        ...e,
        headers: {
            ...s.headers(),
            "content-type": "application/x-www-form-urlencoded",
            ...e.headers
        },
        queryParameters: {
            ...s.queryParameters(),
            ...e.queryParameters
        }
    });
    return pe({
        transporter: r,
        appId: t,
        addAlgoliaAgent(e, t) {
            r.userAgent.add({
                segment: e,
                version: t
            })
        },
        clearCache: ()=>Promise.all([r.requestsCache.clear(), r.responsesCache.clear()]).then((()=>{}
        ))
    }, e.methods)
}
  , Le = e=>(t,s={})=>pe({
    transporter: e.transporter,
    appId: e.appId,
    indexName: t
}, s.methods)
  , qe = e=>(t,s)=>{
    const r = t.map((e=>({
        ...e,
        params: ke(e.params || {})
    })));
    return e.transporter.read({
        method: Te,
        path: "1/indexes/*/queries",
        data: {
            requests: r
        },
        cacheable: !0
    }, s)
}
  , Oe = e=>(t,s)=>Promise.all(t.map((t=>{
    const {facetName: r, facetQuery: n, ...i} = t.params;
    return Le(e)(t.indexName, {
        methods: {
            searchForFacetValues: $e
        }
    }).searchForFacetValues(r, n, {
        ...s,
        ...i
    })
}
)))
  , Me = e=>(t,s)=>e.transporter.read({
    method: Te,
    path: me("1/indexes/%s/query", e.indexName),
    data: {
        query: t
    },
    cacheable: !0
}, s)
  , $e = e=>(t,s,r)=>e.transporter.read({
    method: Te,
    path: me("1/indexes/%s/facets/%s/query", e.indexName, t),
    data: {
        facetQuery: s
    },
    cacheable: !0
}, r)
  , Ue = 1
  , De = 2
  , He = 3;
function Be(e, t, s) {
    const r = {
        appId: e,
        apiKey: t,
        timeouts: {
            connect: 1,
            read: 2,
            write: 30
        },
        requester: {
            send: e=>new Promise((t=>{
                const s = new XMLHttpRequest;
                s.open(e.method, e.url, !0),
                Object.keys(e.headers).forEach((t=>s.setRequestHeader(t, e.headers[t])));
                const r = (e,r)=>setTimeout((()=>{
                    s.abort(),
                    t({
                        status: 0,
                        content: r,
                        isTimedOut: !0
                    })
                }
                ), 1e3 * e)
                  , n = r(e.connectTimeout, "Connection timeout");
                let i;
                s.onreadystatechange = ()=>{
                    s.readyState > s.OPENED && void 0 === i && (clearTimeout(n),
                    i = r(e.responseTimeout, "Socket timeout"))
                }
                ,
                s.onerror = ()=>{
                    0 === s.status && (clearTimeout(n),
                    clearTimeout(i),
                    t({
                        content: s.responseText || "Network request failed",
                        status: s.status,
                        isTimedOut: !1
                    }))
                }
                ,
                s.onload = ()=>{
                    clearTimeout(n),
                    clearTimeout(i),
                    t({
                        content: s.responseText,
                        status: s.status,
                        isTimedOut: !1
                    })
                }
                ,
                s.send(e.data)
            }
            ))
        },
        logger: (n = He,
        {
            debug: (e,t)=>(Ue >= n && console.debug(e, t),
            Promise.resolve()),
            info: (e,t)=>(De >= n && console.info(e, t),
            Promise.resolve()),
            error: (e,t)=>(console.error(e, t),
            Promise.resolve())
        }),
        responsesCache: ue(),
        requestsCache: ue({
            serializable: !1
        }),
        hostsCache: de({
            caches: [le({
                key: `4.6.0-${e}`
            }), ue()]
        }),
        userAgent: Pe("4.6.0").add({
            segment: "Browser",
            version: "lite"
        }),
        authMode: fe.WithinQueryParameters
    };
    var n;
    return Ie({
        ...r,
        ...s,
        methods: {
            search: qe,
            searchForFacetValues: Oe,
            multipleQueries: qe,
            multipleSearchForFacetValues: Oe,
            initIndex: e=>t=>Le(e)(t, {
                methods: {
                    search: Me,
                    searchForFacetValues: $e
                }
            })
        }
    })
}
Be.version = "4.6.0";
const Fe = new WeakMap
  , je = e((e=>r=>{
    if (!(r instanceof t))
        throw new Error("unsafeHTML can only be used in text bindings");
    const n = Fe.get(r);
    if (void 0 !== n && s(e) && e === n.value && r.value === n.fragment)
        return;
    const i = document.createElement("template");
    i.innerHTML = e;
    const a = document.importNode(i.content, !0);
    r.setValue(a),
    Fe.set(r, {
        value: e,
        fragment: a
    })
}
));
!function() {
    if ("undefined" == typeof window)
        return;
    const e = Array.prototype.slice
      , t = Element.prototype.matches || Element.prototype.msMatchesSelector
      , s = ["a[href]", "area[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "details", "summary", "iframe", "object", "embed", "[contenteditable]"].join(",");
    class r {
        constructor(e, t) {
            this._inertManager = t,
            this._rootElement = e,
            this._managedNodes = new Set,
            this._rootElement.hasAttribute("aria-hidden") ? this._savedAriaHidden = this._rootElement.getAttribute("aria-hidden") : this._savedAriaHidden = null,
            this._rootElement.setAttribute("aria-hidden", "true"),
            this._makeSubtreeUnfocusable(this._rootElement),
            this._observer = new MutationObserver(this._onMutation.bind(this)),
            this._observer.observe(this._rootElement, {
                attributes: !0,
                childList: !0,
                subtree: !0
            })
        }
        destructor() {
            this._observer.disconnect(),
            this._rootElement && (null !== this._savedAriaHidden ? this._rootElement.setAttribute("aria-hidden", this._savedAriaHidden) : this._rootElement.removeAttribute("aria-hidden")),
            this._managedNodes.forEach((function(e) {
                this._unmanageNode(e.node)
            }
            ), this),
            this._observer = null,
            this._rootElement = null,
            this._managedNodes = null,
            this._inertManager = null
        }
        get managedNodes() {
            return new Set(this._managedNodes)
        }
        get hasSavedAriaHidden() {
            return null !== this._savedAriaHidden
        }
        set savedAriaHidden(e) {
            this._savedAriaHidden = e
        }
        get savedAriaHidden() {
            return this._savedAriaHidden
        }
        _makeSubtreeUnfocusable(e) {
            i(e, (e=>this._visitNode(e)));
            let t = document.activeElement;
            if (!document.body.contains(e)) {
                let s, r = e;
                for (; r; ) {
                    if (r.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                        s = r;
                        break
                    }
                    r = r.parentNode
                }
                s && (t = s.activeElement)
            }
            e.contains(t) && (t.blur(),
            t === document.activeElement && document.body.focus())
        }
        _visitNode(e) {
            if (e.nodeType !== Node.ELEMENT_NODE)
                return;
            const r = e;
            r !== this._rootElement && r.hasAttribute("inert") && this._adoptInertRoot(r),
            (t.call(r, s) || r.hasAttribute("tabindex")) && this._manageNode(r)
        }
        _manageNode(e) {
            const t = this._inertManager.register(e, this);
            this._managedNodes.add(t)
        }
        _unmanageNode(e) {
            const t = this._inertManager.deregister(e, this);
            t && this._managedNodes.delete(t)
        }
        _unmanageSubtree(e) {
            i(e, (e=>this._unmanageNode(e)))
        }
        _adoptInertRoot(e) {
            let t = this._inertManager.getInertRoot(e);
            t || (this._inertManager.setInert(e, !0),
            t = this._inertManager.getInertRoot(e)),
            t.managedNodes.forEach((function(e) {
                this._manageNode(e.node)
            }
            ), this)
        }
        _onMutation(t, s) {
            t.forEach((function(t) {
                const s = t.target;
                if ("childList" === t.type)
                    e.call(t.addedNodes).forEach((function(e) {
                        this._makeSubtreeUnfocusable(e)
                    }
                    ), this),
                    e.call(t.removedNodes).forEach((function(e) {
                        this._unmanageSubtree(e)
                    }
                    ), this);
                else if ("attributes" === t.type)
                    if ("tabindex" === t.attributeName)
                        this._manageNode(s);
                    else if (s !== this._rootElement && "inert" === t.attributeName && s.hasAttribute("inert")) {
                        this._adoptInertRoot(s);
                        const e = this._inertManager.getInertRoot(s);
                        this._managedNodes.forEach((function(t) {
                            s.contains(t.node) && e._manageNode(t.node)
                        }
                        ))
                    }
            }
            ), this)
        }
    }
    class n {
        constructor(e, t) {
            this._node = e,
            this._overrodeFocusMethod = !1,
            this._inertRoots = new Set([t]),
            this._savedTabIndex = null,
            this._destroyed = !1,
            this.ensureUntabbable()
        }
        destructor() {
            if (this._throwIfDestroyed(),
            this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                const e = this._node;
                null !== this._savedTabIndex ? e.setAttribute("tabindex", this._savedTabIndex) : e.removeAttribute("tabindex"),
                this._overrodeFocusMethod && delete e.focus
            }
            this._node = null,
            this._inertRoots = null,
            this._destroyed = !0
        }
        get destroyed() {
            return this._destroyed
        }
        _throwIfDestroyed() {
            if (this.destroyed)
                throw new Error("Trying to access destroyed InertNode")
        }
        get hasSavedTabIndex() {
            return null !== this._savedTabIndex
        }
        get node() {
            return this._throwIfDestroyed(),
            this._node
        }
        set savedTabIndex(e) {
            this._throwIfDestroyed(),
            this._savedTabIndex = e
        }
        get savedTabIndex() {
            return this._throwIfDestroyed(),
            this._savedTabIndex
        }
        ensureUntabbable() {
            if (this.node.nodeType !== Node.ELEMENT_NODE)
                return;
            const e = this.node;
            if (t.call(e, s)) {
                if (-1 === e.tabIndex && this.hasSavedTabIndex)
                    return;
                e.hasAttribute("tabindex") && (this._savedTabIndex = e.tabIndex),
                e.setAttribute("tabindex", "-1"),
                e.nodeType === Node.ELEMENT_NODE && (e.focus = function() {}
                ,
                this._overrodeFocusMethod = !0)
            } else
                e.hasAttribute("tabindex") && (this._savedTabIndex = e.tabIndex,
                e.removeAttribute("tabindex"))
        }
        addInertRoot(e) {
            this._throwIfDestroyed(),
            this._inertRoots.add(e)
        }
        removeInertRoot(e) {
            this._throwIfDestroyed(),
            this._inertRoots.delete(e),
            0 === this._inertRoots.size && this.destructor()
        }
    }
    function i(e, t, s) {
        if (e.nodeType == Node.ELEMENT_NODE) {
            const s = e;
            t && t(s);
            const r = s.shadowRoot;
            if (r)
                return void i(r, t);
            if ("content" == s.localName) {
                const e = s
                  , r = e.getDistributedNodes ? e.getDistributedNodes() : [];
                for (let e = 0; e < r.length; e++)
                    i(r[e], t);
                return
            }
            if ("slot" == s.localName) {
                const e = s
                  , r = e.assignedNodes ? e.assignedNodes({
                    flatten: !0
                }) : [];
                for (let e = 0; e < r.length; e++)
                    i(r[e], t);
                return
            }
        }
        let r = e.firstChild;
        for (; null != r; )
            i(r, t),
            r = r.nextSibling
    }
    function a(e) {
        if (e.querySelector("style#inert-style, link#inert-style"))
            return;
        const t = document.createElement("style");
        t.setAttribute("id", "inert-style"),
        t.textContent = "\n[inert] {\n  pointer-events: none;\n  cursor: default;\n}\n\n[inert], [inert] * {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n",
        e.appendChild(t)
    }
    const o = new class {
        constructor(e) {
            if (!e)
                throw new Error("Missing required argument; InertManager needs to wrap a document.");
            this._document = e,
            this._managedNodes = new Map,
            this._inertRoots = new Map,
            this._observer = new MutationObserver(this._watchForInert.bind(this)),
            a(e.head || e.body || e.documentElement),
            "loading" === e.readyState ? e.addEventListener("DOMContentLoaded", this._onDocumentLoaded.bind(this)) : this._onDocumentLoaded()
        }
        setInert(e, t) {
            if (t) {
                if (this._inertRoots.has(e))
                    return;
                const t = new r(e,this);
                if (e.setAttribute("inert", ""),
                this._inertRoots.set(e, t),
                !this._document.body.contains(e)) {
                    let t = e.parentNode;
                    for (; t; )
                        11 === t.nodeType && a(t),
                        t = t.parentNode
                }
            } else {
                if (!this._inertRoots.has(e))
                    return;
                this._inertRoots.get(e).destructor(),
                this._inertRoots.delete(e),
                e.removeAttribute("inert")
            }
        }
        getInertRoot(e) {
            return this._inertRoots.get(e)
        }
        register(e, t) {
            let s = this._managedNodes.get(e);
            return void 0 !== s ? s.addInertRoot(t) : s = new n(e,t),
            this._managedNodes.set(e, s),
            s
        }
        deregister(e, t) {
            const s = this._managedNodes.get(e);
            return s ? (s.removeInertRoot(t),
            s.destroyed && this._managedNodes.delete(e),
            s) : null
        }
        _onDocumentLoaded() {
            e.call(this._document.querySelectorAll("[inert]")).forEach((function(e) {
                this.setInert(e, !0)
            }
            ), this),
            this._observer.observe(this._document.body || this._document.documentElement, {
                attributes: !0,
                subtree: !0,
                childList: !0
            })
        }
        _watchForInert(s, r) {
            const n = this;
            s.forEach((function(s) {
                switch (s.type) {
                case "childList":
                    e.call(s.addedNodes).forEach((function(s) {
                        if (s.nodeType !== Node.ELEMENT_NODE)
                            return;
                        const r = e.call(s.querySelectorAll("[inert]"));
                        t.call(s, "[inert]") && r.unshift(s),
                        r.forEach((function(e) {
                            this.setInert(e, !0)
                        }
                        ), n)
                    }
                    ), n);
                    break;
                case "attributes":
                    if ("inert" !== s.attributeName)
                        return;
                    const r = s.target
                      , i = r.hasAttribute("inert");
                    n.setInert(r, i)
                }
            }
            ), this)
        }
    }
    (document);
    Element.prototype.hasOwnProperty("inert") || Object.defineProperty(Element.prototype, "inert", {
        enumerable: !0,
        get: function() {
            return this.hasAttribute("inert")
        },
        set: function(e) {
            o.setInert(this, e)
        }
    })
}();
const Ve = m.action((()=>(document.querySelector("html").scrollTop = 0,
document.querySelectorAll("[data-search-inert]").forEach((e=>{
    e.inert = !0
}
)),
document.body.classList.add("overflow-hidden"),
{
    isSearchActive: !0
})))
  , Je = m.action((()=>(document.querySelectorAll("[data-search-inert]").forEach((e=>{
    e.inert = !1
}
)),
document.body.classList.remove("overflow-hidden"),
{
    isSearchActive: !1
})))
  , ze = Be("0PPZV3EY55", "dc0d3a2d53885be29eacc351026dcdcf").initIndex("prod_developer_chrome");
customElements.define("search-box", class extends r {
    static get properties() {
        return {
            active: {
                type: Boolean,
                reflect: !0
            },
            buttonLabel: {
                type: String
            },
            docsLabel: {
                type: String
            },
            articlesLabel: {
                type: String
            },
            blogLabel: {
                type: String
            },
            locale: {
                type: String
            },
            placeholder: {
                type: String
            },
            results: {
                type: Array
            },
            cursor: {
                type: Number
            }
        }
    }
    set active(e) {
        if (this._active === e)
            return;
        const t = this._active;
        this._active = e,
        e ? Ve() : (this.cursor = -1,
        Je()),
        this.setAttribute("aria-expanded", e.toString()),
        this.requestUpdate("active", t)
    }
    get active() {
        return this._active
    }
    constructor() {
        super(),
        this._active = !1,
        this.buttonLabel = "open search",
        this.docsLabel = "Documentation",
        this.articlesLabel = "Articles",
        this.blogLabel = "Blog",
        this.locale = "en",
        this.placeholder = "Search",
        this.query = "",
        this.results = [],
        this.docsResults = [],
        this.blogResults = [],
        this.resultsCounter = -1,
        this.cursor = -1,
        this.input,
        this.closeIcon = a(o),
        this.searchIcon = a('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.76 13.27L20.49 19 19 20.49l-5.73-5.73C12.2 15.53 10.91 16 9.5 16A6.5 6.5 0 1116 9.5c0 1.41-.47 2.7-1.24 3.77zM9.5 5C7.01 5 5 7.01 5 9.5S7.01 14 9.5 14 14 11.99 14 9.5 11.99 5 9.5 5z"/></svg>'),
        this.renderResult = this.renderResult.bind(this),
        this.search = c(this.search.bind(this), 500)
    }
    clearSearch() {
        this.active = !1,
        this.input.value = "",
        this.search("")
    }
    connectedCallback() {
        super.connectedCallback(),
        this.setAttribute("role", "combobox"),
        this.setAttribute("aria-owns", "search-box__results"),
        this.setAttribute("aria-haspopup", "listbox"),
        this.setAttribute("aria-expanded", "false")
    }
    firstUpdated() {
        this.input = this.querySelector(".search-box__input"),
        window.addEventListener("keydown", (e=>{
            (e.ctrlKey || e.metaKey) && "k" === e.key && this.input.focus()
        }
        ))
    }
    updated(e) {
        e.has("cursor") && (-1 !== this.cursor ? this.input.setAttribute("aria-activedescendant", `search-box__link-${this.cursor}`) : this.input.removeAttribute("aria-activedescendant"))
    }
    onInput(e) {
        this.input.value ? (this.active = !0,
        this.search(e.target.value)) : this.clearSearch()
    }
    onKeyDown(e) {
        switch (e.key) {
        case "Home":
            return e.preventDefault(),
            void this.firstHit();
        case "End":
            return e.preventDefault(),
            void this.lastHit();
        case "ArrowUp":
            return e.preventDefault(),
            void this.prevHit();
        case "ArrowDown":
            return e.preventDefault(),
            void this.nextHit();
        case "Enter":
            return void this.navigateToResult();
        case "Escape":
            return void this.clearSearch()
        }
    }
    firstHit() {
        this.cursor = 0,
        this.scrollHitIntoView()
    }
    nextHit() {
        this.cursor < this.results.length - 1 ? this.cursor++ : this.cursor = 0,
        this.scrollHitIntoView()
    }
    lastHit() {
        this.cursor = this.results.length - 1,
        this.scrollHitIntoView()
    }
    prevHit() {
        this.cursor <= 0 ? this.cursor = this.results.length - 1 : --this.cursor,
        this.scrollHitIntoView()
    }
    navigateToResult() {
        const e = this.querySelector('.search-box__link[aria-selected="true"]');
        e && (window.location.href = e.href)
    }
    scrollHitIntoView() {
        this.requestUpdate().then((()=>{
            const e = this.querySelector('.search-box__link[aria-selected="true"]')
              , t = this.querySelector(".search-box__results");
            e && t && t.scrollTo({
                top: e.offsetTop,
                behavior: "smooth"
            })
        }
        ))
    }
    async toggleSearch() {
        this.active = !this.active,
        this.active ? (await this.updateComplete,
        this.input.focus()) : this.clearSearch()
    }
    async search(e) {
        if (this.query = e.trim(),
        "" === this.query)
            return this.results = [],
            this.docsResults = [],
            void (this.blogResults = []);
        try {
            const {hits: t} = await ze.search(e, {
                hitsPerPage: 10,
                filters: `locale:"${this.locale}"`,
                highlightPreTag: "<strong>",
                highlightPostTag: "</strong>",
                attributesToSnippet: ["content:25"],
                snippetEllipsisText: ""
            });
            this.results = t.map((e=>{
                const t = ["title"];
                for (const s of t) {
                    const t = e._highlightResult[s];
                    t && "full" === t.matchLevel && (e[s] = t.value)
                }
                return e.snippet = e._snippetResult.content?.value || e._snippetResult.description?.value || "",
                e
            }
            )),
            this.docsResults = this.results.filter((e=>"doc" === e.type)),
            this.articlesResults = this.results.filter((e=>"article" === e.type)),
            this.blogResults = this.results.filter((e=>"blogPost" === e.type))
        } catch (e) {
            console.error(e),
            console.error(e.debugData)
        }
    }
    renderContent(e) {
        if (e && 0 !== e.length)
            return n`<p>${je(e)}</p>`
    }
    renderImage(e) {
        if (e && 0 !== e.length)
            return n`<img
      class="search-box__thumbnail"
      src="${e}"
      width="100"
      height="100"
      alt=""
    />`
    }
    renderResult(e) {
        return this.resultsCounter += 1,
        n`
      <div role="presentation">
        <a
          id="search-box__link-${this.resultsCounter}"
          class="search-box__link"
          href="${e.url}"
          aria-selected="${this.resultsCounter === this.cursor}"
          role="option"
        >
          <div>
            <h3 class="search-box__title type--h6">
              ${je(e.title)}
            </h3>
            <div class="search-box__snippet type--small">
              ${this.renderContent(e.snippet)}
            </div>
          </div>
          ${this.renderImage(e.image)}
        </a>
      </div>
    `
    }
    renderResults() {
        if (this.active)
            return this.blogResults = this.blogResults || [],
            this.docsResults = this.docsResults || [],
            this.resultsCounter = -1,
            n`
      <div
        id="search-box__results"
        class="search-box__results"
        role="listbox"
        aria-label="${this.placeholder}"
      >
        ${this.blogResults.length ? n`
              <div class="search-box__result-heading type--label">
                ${this.blogLabel.toUpperCase()}
              </div>
              ${this.blogResults.map(this.renderResult)}
            ` : ""}
        ${this.articlesResults?.length ? n`
              <div class="search-box__result-heading type--label">
                ${this.articlesLabel.toUpperCase()}
              </div>
              ${this.articlesResults.map(this.renderResult)}
            ` : ""}
        ${this.docsResults.length ? n`
              <div class="search-box__result-heading type--label">
                ${this.docsLabel.toUpperCase()}
              </div>
              ${this.docsResults.map(this.renderResult)}
            ` : ""}
      </div>
    `
    }
    render() {
        return n`
      <div class="search-box__inner" role="presentation">
        <button
          @click="${this.toggleSearch}"
          aria-label="${this.buttonLabel}"
          class="search-box__btn"
        >
          ${this.active ? this.closeIcon : this.searchIcon}
        </button>

        <input
          type="text"
          class="search-box__input"
          placeholder="${this.placeholder}"
          @input="${this.onInput}"
          @keydown="${this.onKeyDown}"
          aria-label="${this.placeholder}"
          aria-autocomplete="list"
        />
      </div>
      ${this.renderResults()}
    `
    }
}
);
const We = new WeakSet
  , Ke = e=>{
    e && !We.has(e) && (e.addEventListener("click", (function(e) {
        const t = e.currentTarget
          , s = !function(e) {
            return "true" === e.getAttribute("aria-expanded")
        }(t);
        t.setAttribute("aria-expanded", s ? "true" : "false")
    }
    )),
    We.add(e))
}
;
customElements.define("navigation-tree", class extends r {
    constructor() {
        super(),
        this.onBack = this.onBack.bind(this)
    }
    connectedCallback() {
        this.querySelectorAll("[data-expandable]").forEach(Ke),
        this.backBtn = this.querySelector(".navigation-tree__back"),
        this.backBtn.addEventListener("click", this.onBack)
    }
    disconnectedCallback() {
        this.backBtn.removeEventListener("click", this.onBack)
    }
    onBack() {
        this.dispatchEvent(new Event("navigation-tree-back",{
            bubbles: !0
        }))
    }
}
);
customElements.define("navigation-rail", class extends r {
    constructor() {
        super(),
        this.onClose = this.onClose.bind(this)
    }
    connectedCallback() {
        this.closeBtn = this.querySelector(".navigation-rail__close"),
        this.closeBtn.addEventListener("click", this.onClose)
    }
    disconnectedCallback() {
        this.closeBtn.removeEventListener("click", this.onClose)
    }
    onClose() {
        this.dispatchEvent(new Event("navigation-rail-collapse",{
            bubbles: !0
        }))
    }
}
);
const Qe = m.action((()=>(document.querySelectorAll("[data-side-nav-inert").forEach((e=>{
    e.inert = !0
}
)),
document.querySelector("side-nav").expanded = !0,
document.body.classList.add("overflow-hidden"),
{
    isSideNavExpanded: !0
})))
  , Xe = m.action((()=>(document.querySelectorAll("[data-side-nav-inert").forEach((e=>{
    e.inert = !1
}
)),
document.querySelector("side-nav").expanded = !1,
document.body.classList.remove("overflow-hidden"),
{
    isSideNavExpanded: !1
})))
  , Ge = m.action((()=>{
    document.querySelector(".top-nav__hamburger").focus()
}
));
customElements.define("side-nav", class extends r {
    static get properties() {
        return {
            type: {
                type: String,
                reflect: !0
            },
            view: {
                type: String,
                reflect: !0
            },
            animating: {
                type: Boolean,
                reflect: !0
            },
            expanding: {
                type: Boolean
            },
            collapsing: {
                type: Boolean
            },
            switchingViews: {
                type: Boolean
            },
            expanded: {
                type: Boolean,
                attribute: !1
            }
        }
    }
    set expanded(e) {
        this._expanded !== e && (e ? (this.setAttribute("expanded", ""),
        this.expanding = !0,
        this.intersectionObserver.observe(this)) : (this.removeAttribute("expanded"),
        this.collapsing = !0,
        this.intersectionObserver.disconnect()),
        this.animating = !0,
        this._expanded = e)
    }
    get expanded() {
        return this._expanded
    }
    constructor() {
        super(),
        this.type = "site",
        this.animating = !1,
        this.expanding = !1,
        this.collapsing = !1,
        this.switchingViews = !1,
        this._expanded = !1,
        this.onBack = this.onBack.bind(this),
        this.onTransitionEnd = this.onTransitionEnd.bind(this),
        this.intersectionObserver = new IntersectionObserver((e=>{
            let t = !1;
            for (const s of e)
                s.target === this && (t = s.intersectionRatio > 0);
            this.onVisibleChange(t)
        }
        ))
    }
    connectedCallback() {
        super.connectedCallback(),
        "project" === this.type ? this.view = "project" : this.view = "site",
        this.projectView = this.querySelector("navigation-tree"),
        this.siteView = this.querySelector("navigation-rail"),
        this.addEventListener("click", Xe),
        this.querySelectorAll("navigation-rail, navigation-tree").forEach((e=>e.addEventListener("click", this.onBlockClicks))),
        this.addEventListener("navigation-rail-collapse", Xe),
        this.addEventListener("navigation-tree-back", this.onBack),
        this.addEventListener("transitionend", this.onTransitionEnd)
    }
    disconnectedCallback() {
        this.removeEventListener("click", Xe),
        this.querySelectorAll("navigation-rail, navigation-tree").forEach((e=>e.removeEventListener("click", this.onBlockClicks))),
        this.removeEventListener("navigation-rail-collapse", Xe),
        this.removeEventListener("navigation-tree-back", this.onBack),
        this.removeEventListener("transitionend", this.onTransitionEnd)
    }
    onVisibleChange(e) {
        e || Xe()
    }
    onBlockClicks(e) {
        e.target.closest("a") || e.stopPropagation()
    }
    onBack() {
        this.animating = !0,
        this.switchingViews = !0,
        this.view = "site"
    }
    onTransitionEnd() {
        return this.animating = !1,
        this.collapsing ? (this.collapsing = !1,
        "project" === this.type && (this.view = "project"),
        void Ge()) : this.expanding ? (this.expanding = !1,
        void ("project" === this.type ? this.projectView.focus() : this.siteView.focus())) : this.switchingViews ? (this.switchingViews = !1,
        void this.siteView.focus()) : void 0
    }
}
);
class Ye extends r {
    constructor() {
        super(),
        this.onStateChanged = this.onStateChanged.bind(this)
    }
    connectedCallback() {
        super.connectedCallback(),
        m.subscribe(this.onStateChanged),
        this.onStateChanged(m.getState())
    }
    disconnectedCallback() {
        super.disconnectedCallback(),
        m.unsubscribe(this.onStateChanged)
    }
    onStateChanged(e) {}
}
customElements.define("top-nav", class extends Ye {
    connectedCallback() {
        super.connectedCallback(),
        this.hamburgerBtn = this.querySelector(".top-nav__hamburger"),
        this.hamburgerBtn.addEventListener("click", Qe)
    }
    disconnectedCallback() {
        super.disconnectedCallback(),
        this.hamburgerBtn.removeEventListener("click", Qe)
    }
    onStateChanged({isSearchActive: e}) {
        e ? this.setAttribute("data-search-active", "") : this.removeAttribute("data-search-active")
    }
}
);
customElements.define("share-button", class extends r {
    constructor() {
        super(),
        this.onClick = this.onClick.bind(this)
    }
    connectedCallback() {
        this.addEventListener("click", this.onClick)
    }
    disconnectedCallback() {
        this.removeEventListener("click", this.onClick)
    }
    onClick(e) {
        "share"in window.navigator && (e.preventDefault(),
        navigator.share({
            text: this.shareText,
            url: this.shareUrl
        }))
    }
    get shareUrl() {
        return window.location.href
    }
    get shareText() {
        const e = this.getAttribute("message");
        return e && e.length ? e : document.title
    }
}
);
customElements.define("web-tabs", class extends r {
    constructor() {
        super(),
        this._tabPanels = [],
        this.onSelect = this.onSelect.bind(this)
    }
    connectedCallback() {
        super.connectedCallback(),
        this._id = `tabs-${l("tabs-")}`,
        this._selected = this._getSelectedTabIndex()
    }
    onSelect(e) {
        const t = parseInt(e.target.id.split("-").pop(), 10);
        this._selected !== t && this._select(t)
    }
    _select(e) {
        this._selected = e,
        this._tabPanels.forEach((e=>{
            const t = parseInt(e.id.split("-").pop(), 10)
              , s = "#" + e.getAttribute("aria-labelledby")
              , r = this.querySelector(s);
            this._selected !== t ? (e.setAttribute("hidden", "hidden"),
            r?.setAttribute("tabindex", "-1"),
            r?.setAttribute("aria-selected", "false")) : (e.removeAttribute("hidden"),
            r?.setAttribute("tabindex", "0"),
            r?.setAttribute("aria-selected", "true"))
        }
        ))
    }
    _formatTabs() {
        return this._tabPanels.map(((e,t)=>{
            const s = e.getAttribute("title");
            e.removeAttribute("title");
            const r = `${this._id}__tab-${t}`
              , i = `${this._id}__tabpanel-${t}`;
            return e.setAttribute("id", i),
            e.setAttribute("role", "tabpanel"),
            e.setAttribute("aria-labelledby", r),
            e.setAttribute("tabindex", 0),
            t !== this._selected ? e.setAttribute("hidden", "hidden") : e.removeAttribute("hidden"),
            n`<button
        role="tab"
        id="${r}"
        aria-selected="${t === this._selected}"
        aria-controls="${i}"
        tabindex="${t === this._selected ? 0 : -1}"
        @click="${this.onSelect}"
      >
        ${s}
      </button>`
        }
        ))
    }
    _getSelectedTabIndex() {
        const e = window.location.hash;
        if (!e)
            return 0;
        const t = this.querySelector(e);
        if (!t)
            return 0;
        const s = t.closest("web-tab");
        return s ? Array.from(this.children).indexOf(s) : 0
    }
    render() {
        this._tabPanels = Array.from(this.children);
        const e = this._formatTabs();
        return n`
      <div role="tablist">${e}</div>
      ${this._tabPanels}
    `
    }
}
),
window.JSCompiler_renameProperty = (e,t)=>e;
const Ze = {
    toAttribute(e, t) {
        switch (t) {
        case Boolean:
            return e ? "" : null;
        case Object:
        case Array:
            return null == e ? e : JSON.stringify(e)
        }
        return e
    },
    fromAttribute(e, t) {
        switch (t) {
        case Boolean:
            return null !== e;
        case Number:
            return null === e ? null : Number(e);
        case Object:
        case Array:
            return JSON.parse(e)
        }
        return e
    }
}
  , et = (e,t)=>t !== e && (t == t || e == e)
  , tt = {
    attribute: !0,
    type: String,
    converter: Ze,
    reflect: !1,
    hasChanged: et
};
class st extends HTMLElement {
    constructor() {
        super(),
        this.initialize()
    }
    static get observedAttributes() {
        this.finalize();
        const e = [];
        return this._classProperties.forEach(((t,s)=>{
            const r = this._attributeNameForProperty(s, t);
            void 0 !== r && (this._attributeToPropertyMap.set(r, s),
            e.push(r))
        }
        )),
        e
    }
    static _ensureClassProperties() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
            this._classProperties = new Map;
            const e = Object.getPrototypeOf(this)._classProperties;
            void 0 !== e && e.forEach(((e,t)=>this._classProperties.set(t, e)))
        }
    }
    static createProperty(e, t=tt) {
        if (this._ensureClassProperties(),
        this._classProperties.set(e, t),
        t.noAccessor || this.prototype.hasOwnProperty(e))
            return;
        const s = "symbol" == typeof e ? Symbol() : `__${e}`
          , r = this.getPropertyDescriptor(e, s, t);
        void 0 !== r && Object.defineProperty(this.prototype, e, r)
    }
    static getPropertyDescriptor(e, t, s) {
        return {
            get() {
                return this[t]
            },
            set(r) {
                const n = this[e];
                this[t] = r,
                this.requestUpdateInternal(e, n, s)
            },
            configurable: !0,
            enumerable: !0
        }
    }
    static getPropertyOptions(e) {
        return this._classProperties && this._classProperties.get(e) || tt
    }
    static finalize() {
        const e = Object.getPrototypeOf(this);
        if (e.hasOwnProperty("finalized") || e.finalize(),
        this.finalized = !0,
        this._ensureClassProperties(),
        this._attributeToPropertyMap = new Map,
        this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
            const e = this.properties
              , t = [...Object.getOwnPropertyNames(e), ..."function" == typeof Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : []];
            for (const s of t)
                this.createProperty(s, e[s])
        }
    }
    static _attributeNameForProperty(e, t) {
        const s = t.attribute;
        return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof e ? e.toLowerCase() : void 0
    }
    static _valueHasChanged(e, t, s=et) {
        return s(e, t)
    }
    static _propertyValueFromAttribute(e, t) {
        const s = t.type
          , r = t.converter || Ze
          , n = "function" == typeof r ? r : r.fromAttribute;
        return n ? n(e, s) : e
    }
    static _propertyValueToAttribute(e, t) {
        if (void 0 === t.reflect)
            return;
        const s = t.type
          , r = t.converter;
        return (r && r.toAttribute || Ze.toAttribute)(e, s)
    }
    initialize() {
        this._updateState = 0,
        this._updatePromise = new Promise((e=>this._enableUpdatingResolver = e)),
        this._changedProperties = new Map,
        this._saveInstanceProperties(),
        this.requestUpdateInternal()
    }
    _saveInstanceProperties() {
        this.constructor._classProperties.forEach(((e,t)=>{
            if (this.hasOwnProperty(t)) {
                const e = this[t];
                delete this[t],
                this._instanceProperties || (this._instanceProperties = new Map),
                this._instanceProperties.set(t, e)
            }
        }
        ))
    }
    _applyInstanceProperties() {
        this._instanceProperties.forEach(((e,t)=>this[t] = e)),
        this._instanceProperties = void 0
    }
    connectedCallback() {
        this.enableUpdating()
    }
    enableUpdating() {
        void 0 !== this._enableUpdatingResolver && (this._enableUpdatingResolver(),
        this._enableUpdatingResolver = void 0)
    }
    disconnectedCallback() {}
    attributeChangedCallback(e, t, s) {
        t !== s && this._attributeToProperty(e, s)
    }
    _propertyToAttribute(e, t, s=tt) {
        const r = this.constructor
          , n = r._attributeNameForProperty(e, s);
        if (void 0 !== n) {
            const e = r._propertyValueToAttribute(t, s);
            if (void 0 === e)
                return;
            this._updateState = 8 | this._updateState,
            null == e ? this.removeAttribute(n) : this.setAttribute(n, e),
            this._updateState = -9 & this._updateState
        }
    }
    _attributeToProperty(e, t) {
        if (8 & this._updateState)
            return;
        const s = this.constructor
          , r = s._attributeToPropertyMap.get(e);
        if (void 0 !== r) {
            const e = s.getPropertyOptions(r);
            this._updateState = 16 | this._updateState,
            this[r] = s._propertyValueFromAttribute(t, e),
            this._updateState = -17 & this._updateState
        }
    }
    requestUpdateInternal(e, t, s) {
        let r = !0;
        if (void 0 !== e) {
            const n = this.constructor;
            s = s || n.getPropertyOptions(e),
            n._valueHasChanged(this[e], t, s.hasChanged) ? (this._changedProperties.has(e) || this._changedProperties.set(e, t),
            !0 !== s.reflect || 16 & this._updateState || (void 0 === this._reflectingProperties && (this._reflectingProperties = new Map),
            this._reflectingProperties.set(e, s))) : r = !1
        }
        !this._hasRequestedUpdate && r && (this._updatePromise = this._enqueueUpdate())
    }
    requestUpdate(e, t) {
        return this.requestUpdateInternal(e, t),
        this.updateComplete
    }
    async _enqueueUpdate() {
        this._updateState = 4 | this._updateState;
        try {
            await this._updatePromise
        } catch (e) {}
        const e = this.performUpdate();
        return null != e && await e,
        !this._hasRequestedUpdate
    }
    get _hasRequestedUpdate() {
        return 4 & this._updateState
    }
    get hasUpdated() {
        return 1 & this._updateState
    }
    performUpdate() {
        if (!this._hasRequestedUpdate)
            return;
        this._instanceProperties && this._applyInstanceProperties();
        let e = !1;
        const t = this._changedProperties;
        try {
            e = this.shouldUpdate(t),
            e ? this.update(t) : this._markUpdated()
        } catch (t) {
            throw e = !1,
            this._markUpdated(),
            t
        }
        e && (1 & this._updateState || (this._updateState = 1 | this._updateState,
        this.firstUpdated(t)),
        this.updated(t))
    }
    _markUpdated() {
        this._changedProperties = new Map,
        this._updateState = -5 & this._updateState
    }
    get updateComplete() {
        return this._getUpdateComplete()
    }
    _getUpdateComplete() {
        return this.getUpdateComplete()
    }
    getUpdateComplete() {
        return this._updatePromise
    }
    shouldUpdate(e) {
        return !0
    }
    update(e) {
        void 0 !== this._reflectingProperties && this._reflectingProperties.size > 0 && (this._reflectingProperties.forEach(((e,t)=>this._propertyToAttribute(t, this[t], e))),
        this._reflectingProperties = void 0),
        this._markUpdated()
    }
    updated(e) {}
    firstUpdated(e) {}
}
st.finalized = !0;
const rt = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets"in Document.prototype && "replace"in CSSStyleSheet.prototype
  , nt = Symbol();
class it {
    constructor(e, t) {
        if (t !== nt)
            throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = e
    }
    get styleSheet() {
        return void 0 === this._styleSheet && (rt ? (this._styleSheet = new CSSStyleSheet,
        this._styleSheet.replaceSync(this.cssText)) : this._styleSheet = null),
        this._styleSheet
    }
    toString() {
        return this.cssText
    }
}
(window.litElementVersions || (window.litElementVersions = [])).push("2.5.1");
const at = {};
class ot extends st {
    static getStyles() {
        return this.styles
    }
    static _getUniqueStyles() {
        if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this)))
            return;
        const e = this.getStyles();
        if (Array.isArray(e)) {
            const t = (e,s)=>e.reduceRight(((e,s)=>Array.isArray(s) ? t(s, e) : (e.add(s),
            e)), s)
              , s = t(e, new Set)
              , r = [];
            s.forEach((e=>r.unshift(e))),
            this._styles = r
        } else
            this._styles = void 0 === e ? [] : [e];
        this._styles = this._styles.map((e=>{
            if (e instanceof CSSStyleSheet && !rt) {
                const t = Array.prototype.slice.call(e.cssRules).reduce(((e,t)=>e + t.cssText), "");
                return new it(String(t),nt)
            }
            return e
        }
        ))
    }
    initialize() {
        super.initialize(),
        this.constructor._getUniqueStyles(),
        this.renderRoot = this.createRenderRoot(),
        window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot && this.adoptStyles()
    }
    createRenderRoot() {
        return this.attachShadow(this.constructor.shadowRootOptions)
    }
    adoptStyles() {
        const e = this.constructor._styles;
        0 !== e.length && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow ? rt ? this.renderRoot.adoptedStyleSheets = e.map((e=>e instanceof CSSStyleSheet ? e : e.styleSheet)) : this._needsShimAdoptedStyleSheets = !0 : window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map((e=>e.cssText)), this.localName))
    }
    connectedCallback() {
        super.connectedCallback(),
        this.hasUpdated && void 0 !== window.ShadyCSS && window.ShadyCSS.styleElement(this)
    }
    update(e) {
        const t = this.render();
        super.update(e),
        t !== at && this.constructor.render(t, this.renderRoot, {
            scopeName: this.localName,
            eventContext: this
        }),
        this._needsShimAdoptedStyleSheets && (this._needsShimAdoptedStyleSheets = !1,
        this.constructor._styles.forEach((e=>{
            const t = document.createElement("style");
            t.textContent = e.cssText,
            this.renderRoot.appendChild(t)
        }
        )))
    }
    render() {
        return at
    }
}
ot.finalized = !0,
ot.render = i,
ot.shadowRootOptions = {
    mode: "open"
};
class ct extends ot {
    createRenderRoot() {
        return this
    }
}
const lt = {
    en: "English",
    pl: "Polski",
    es: "Espaol",
    ko: "",
    zh: "",
    ru: "P",
    pt: "Portugus",
    ja: ""
};
class dt extends ct {
    static get properties() {
        return {
            current: {
                type: String
            },
            supported: {
                type: String
            }
        }
    }
    constructor() {
        super(),
        this.supported = Object.keys(lt).join(",") || "",
        this.supportedLanguages = []
    }
    onChange() {}
    connectedCallback() {
        super.connectedCallback(),
        this.current = document.documentElement.lang,
        this.supportedLanguages = this.supported.split(",")
    }
    renderOption(e) {
        let t = lt[e];
        return t ? (t = t.toUpperCase(),
        this.current === e ? n`
          <option value="${e}" selected>
            ${t} (${e})
          </option>
        ` : n`
          <option value="${e}">${t} (${e})</option>
        `) : ""
    }
    render() {
        const e = Array.from(document.querySelectorAll('link[rel="alternate"]')).filter((e=>e.hreflang)).map((e=>e.hreflang))
          , t = document.documentElement.lang
          , s = this.supportedLanguages.filter((s=>e.includes(s) || s === t));
        return n`
      <div class="language-select">
        <label class="w-visually-hidden" for="preferred-language">
          Choose language
        </label>
        <select id="preferred-language" @change="${this.onChange}">
          ${s.map((e=>this.renderOption(e)))}
        </select>
      </div>
    `
    }
}
customElements.define("language-select", class extends dt {
    constructor() {
        super(),
        this.current = "en",
        this.supportedLanguages = []
    }
    onChange(e) {
        const t = e.target.value;
        if (this.supportedLanguages.includes(t) && t !== this.current) {
            const e = location.pathname.split("/")
              , s = this.supportedLanguages.includes(e[1]) ? 1 : 0;
            e.splice(1, s, t),
            location.href = e.join("/")
        }
    }
}
);
class ut extends HTMLElement {
    connectedCallback() {
        this.setAttribute("active", ""),
        this.addEventListener("click", (e=>{
            e.target.closest("[data-banner-close-btn]") && (this.savePreference(),
            this.close())
        }
        ))
    }
    savePreference() {
        const e = this.getAttribute("storage-key") || ""
          , t = this.querySelector("a[href]");
        if (t) {
            const s = t.getAttribute("href") || "";
            localStorage.setItem(e, s)
        }
    }
    close() {
        this.setAttribute("hidden", "true")
    }
}
window.customElements.define("announcement-banner", ut);
customElements.define("toc-active", class extends r {
    constructor() {
        super(),
        this.updateHeading = ()=>{}
        ,
        this.previousActiveAnchor = null,
        this.visibleHeadings = new Set;
        let e = 0;
        this.observer = new IntersectionObserver((t=>{
            t.forEach((t=>{
                const s = t.target;
                t.isIntersecting ? this.visibleHeadings.add(s) : this.visibleHeadings.delete(s),
                e || (e = window.requestAnimationFrame((()=>{
                    e = 0,
                    this.updateHeading()
                }
                )))
            }
            ))
        }
        ),{
            threshold: .5
        })
    }
    connectedCallback() {
        super.connectedCallback();
        const e = document.scrollingElement
          , t = document.body.querySelector("article");
        if (!t || !e)
            return;
        const s = {}
          , r = this.querySelectorAll("a[href]");
        let n = null;
        for (const e of r) {
            const t = e.getAttribute("href") ?? "";
            t.startsWith("#") && (s[t.substr(1)] = e,
            null === n && (n = e))
        }
        const i = t.querySelectorAll("[id]");
        for (const e of i)
            this.observer.observe(e);
        this.updateHeading = ()=>{
            let e = null;
            for (const t of i)
                if (this.visibleHeadings.has(t) && t.id in s) {
                    e = s[t.id];
                    break
                }
            e !== this.previousActiveAnchor && e && (this.previousActiveAnchor && this.previousActiveAnchor.removeAttribute("toc--active"),
            e.setAttribute("toc--active", ""),
            this.previousActiveAnchor = e,
            e === n ? this.scrollTop = 0 : function(e, t) {
                const s = e.getBoundingClientRect()
                  , r = t.getBoundingClientRect()
                  , n = r.top - s.top;
                if (n > 0)
                    t.scrollTop -= n;
                else {
                    const e = s.bottom - r.bottom;
                    e > 0 && (t.scrollTop += e)
                }
            }(e, this))
        }
    }
    disconnectedCallback() {
        super.disconnectedCallback(),
        this.observer.disconnect(),
        this.previousActiveAnchor && (this.previousActiveAnchor.removeAttribute("toc--active"),
        this.previousActiveAnchor = null)
    }
}
);
customElements.define("select-loader", class extends r {
    constructor() {
        super(),
        this.addEventListener("change", (e=>{
            const t = e.target;
            if (!(t instanceof HTMLSelectElement))
                return;
            const s = t.selectedOptions[0];
            if (s) {
                const e = s.getAttribute("href");
                e && window.location.assign(e)
            }
            t.selectedIndex = 0
        }
        ))
    }
}
);
    
    }
    
 
 def timestwo(x):
    return x * 2
 def  timesthree(x):
    return x * 3
  def square(x):
        return x * x
  def power(x,y):
        return x ** y
  print (timestwo(2))
  print (timesthree(3))
  print (square(4))
  print (power(5,3))
  
  from minimath import *
  
  print(Select operation.\n")
  